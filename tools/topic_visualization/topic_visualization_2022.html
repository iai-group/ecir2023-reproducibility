<!-- Interactive visualization of the topics
Inspired from https://bl.ocks.org/d3noob/8375092 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>TREC CAsT - Topic Visualization</title>

    <style>
        .node {
            cursor: pointer;
        }

        .node circle {
            fill: #fff;
            stroke-width: 3px;
        }

        .node text {
            font: 12px sans-serif;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }

        .textdiv {
            font-family: "Open Sans", Helvetica, Arial, sans-serif;
            font-size: 14px;
            padding: 7px;
        }

        div.tooltip {
            position: absolute;
            text-align: left;
            width: 300px;
            padding: 5px;
            font-family: "Open Sans", Helvetica, Arial, sans-serif;
            font-size: 14px;
            background: white;
            border-style: solid;
            border-color: black;
            border-radius: 8px;
            pointer-events: none;
        }
    </style>

</head>

<body>

    Topic number: <input type="number" id="topicNumber" value=132>

    <!-- load the d3.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
    <script type="text/javascript">

        var json_path = "../../data/topics/2022/2022_automatic_evaluation_topics_tree_v1.0.json"

        function list_to_tree(list) {
            var map = {}, node, roots = [], i;

            for (i = 0; i < list.length; i += 1) {
                map[list[i].number] = i; // initialize the map
                list[i].children = []; // initialize the children
            }

            for (i = 0; i < list.length; i += 1) {
                node = list[i];
                if (node.parent !== undefined) {
                    // if you have dangling branches check that map[node.parent] exists
                    list[map[node.parent]].children.push(node);
                } else {
                    node.parent = "null";
                    roots.push(node);
                }
            }
            return roots;
        }

        // A function that change the topic
        function changeTopic(number) {
            number = this.value;
            showTopic(this.value);
        }

        function showTopic(number) {
            d3.json(json_path, function (json) {
                treeData = json.find(x => x.number == number);
                treeData = list_to_tree(treeData["turn"]);
                root = treeData[0];
                root.x0 = height / 2;
                root.y0 = 0;

                update(root);
            })
        }
        showTopic(document.getElementById("topicNumber").value);

        // ************** Generate the tree diagram	 *****************
        var realWidth = window.innerWidth,
            realHeight = window.innerHeight;

        var margin = { top: 20, right: 120, bottom: 20, left: 120 },
            width = realWidth - margin.right - margin.left,
            height = realHeight - margin.top - margin.bottom;

        var i = 0,
            duration = 750,
            root;

        var tree = d3.layout.tree()
            .size([height, width]);

        var diagonal = d3.svg.diagonal()
            .projection(function (d) { return [d.x, d.y]; });

        var svg = d3.select("body").append("div").attr("id", "container").append("svg")
            .attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("class", "drawarea")
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        d3.select("#topicNumber").on("input", changeTopic)

        d3.select(self.frameElement).style("height", "800px");

        // Define the div for the tooltip
        var div = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        function update(source) {

            // Compute the new tree layout.
            var nodes = tree.nodes(root).reverse(),
                links = tree.links(nodes);

            // Normalize for fixed-depth.
            nodes.forEach(function (d) { d.y = d.depth * 120; });

            // Update the nodes…
            var node = svg.selectAll("g.node")
                .data(nodes, function (d) { return d.id || (d.id = ++i); });

            // Enter any new nodes at the parent's previous position.
            var nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", function (d) { return "translate(" + source.x0 + "," + source.y0 + ")"; })
                .on("click", click);

            nodeEnter.append("circle")
                .attr("r", 1e-6)
                .style("stroke", function (d) { return d.participant === "User" ? "steelblue" : d.participant === "System" ? "navy" : "#fff"; })
                .style("fill", function (d) { return d._children && d.participant === "User" ? "lightsteelblue" : d._children && d.participant === "System" ? "navy" : "#fff"; });

            nodeEnter.append("foreignObject")
                .attr("width", 160)
                .attr("height", 100)
                .append("xhtml:div")
                .attr("dy", ".75em")
                .html(function (d) { return d.utterance || d.response; })
                .attr("class", "textdiv")
                .on("mouseover", function (d) {
                    d3.select(this).html("");
                    div.transition()
                        .duration(200)
                        .style("opacity", 1);
                    div.html(d.utterance || d.response)
                        .style("left", (d3.event.pageX) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function (d) {
                    d3.select(this).html(d.utterance || d.response);
                    div.transition()
                        .duration(500)
                        .style("opacity", 0);
                }); //textdiv class allows us to style the text easily with CSS


            // Transition nodes to their new position.
            var nodeUpdate = node.transition()
                .duration(duration)
                .attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; });

            nodeUpdate.select("circle")
                .attr("r", 10)
                .style("stroke", function (d) { return d.participant === "User" ? "steelblue" : d.participant === "System" ? "navy" : "#fff"; })
                .style("fill", function (d) { return d._children && d.participant === "User" ? "lightsteelblue" : d._children && d.participant === "System" ? "navy" : "#fff"; });


            nodeUpdate.select("foreignObject")
                .style("fill-opacity", 1);

            // Transition exiting nodes to the parent's new position.
            var nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", function (d) { return "translate(" + source.x + "," + source.y + ")"; })
                .remove();

            nodeExit.select("circle")
                .attr("r", 1e-6);

            nodeExit.select("foreignObject")
                .style("fill-opacity", 1e-6);

            // Update the links…
            var link = svg.selectAll("path.link")
                .data(links, function (d) { return d.target.id; });

            // Enter any new links at the parent's previous position.
            link.enter().insert("path", "g")
                .attr("class", "link")
                .attr("d", function (d) {
                    var o = { x: source.x0, y: source.y0 };
                    return diagonal({ source: o, target: o });
                });

            // Transition links to their new position.
            link.transition()
                .duration(duration)
                .attr("d", diagonal);

            // Transition exiting nodes to the parent's new position.
            link.exit().transition()
                .duration(duration)
                .attr("d", function (d) {
                    var o = { x: source.x, y: source.y };
                    return diagonal({ source: o, target: o });
                })
                .remove();

            // Stash the old positions for transition.
            nodes.forEach(function (d) {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            d3.select("svg")
                .call(d3.behavior.zoom()
                    .scaleExtent([-.5, 1])
                    .on("zoom", zoom));

        }

        // Toggle children on click.
        function click(d) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            update(d);
        }

        function zoom() {
            var scale = d3.event.scale,
                translation = d3.event.translate,
                tbound = -height * scale,
                bbound = height * scale,
                lbound = (-width + margin.right) * scale,
                rbound = (width - margin.left) * scale;
            // limit translation to thresholds
            translation = [
                Math.max(Math.min(translation[0], rbound), lbound),
                Math.max(Math.min(translation[1], bbound), tbound)
            ];
            d3.select(".drawarea")
                .attr("transform", "translate(" + translation + ")" +
                    " scale(" + scale + ")");
        }

    </script>

</body>

</html>